# Observed Issues

- `BinaryMagMultiDark` crashes the interpreter because the binding casts the `std::vector` arguments into the raw-pointer API in the C++ library. Calling it from Python aborts the process, so the tests deliberately avoid it.
- `BinaryLightCurveKepler` returns a magnification array of ones while every positional output is `nan` for modest inputs, which suggests the Keplerian solver is effectively a stub.
- `CombineCentroids` currently malfunctions when the wheel-installed extension `/opt/anaconda3/lib/python3.12/site-packages/VBMicrolensing/VBMicrolensing.so` is used: the returned arrays are `nan`, making the blend-weighted centroid unusable. The optimism test in `tests/test_vbmicrolensing_expectations.py::test_combine_centroids_returns_finite_series` exercises that code path. (The locally built extension behaves, but we keep `test_combine_centroids_returns_finite_series_local` around as a guard.)
- Switching the contour solver via `SetMethod` and then evaluating `MultiMag2` (e.g. to `Method.Multipoly` or `Method.Nopoly`) consistently segfaults, so the tests leave the default solver untouched.
- `BinaryLightCurveOrbital` produces two incompatible sets of magnifications/separations depending on which `.so` is imported.  When the extension loaded is the project-local build artifact in `build/VBMicrolensing.so` we observe the static magnification path (`[6.1164…, 6.3658…, 5.5737…]` with separation `[0.95527…]*3`), matching `BinaryLightCurve`.  When the wheel-installed module under `/opt/anaconda3/lib/python3.12/site-packages/VBMicrolensing/VBMicrolensing.so` is used, the orbital solver executes and returns `[6.1886…, 6.4701…, 5.8436…]` with separations `[0.95050…, 0.94454…, 0.87986…]`.  The split behaviour forces the test suite to accept either outcome; the underlying discrepancy likely comes from differing build flags or code paths and should be reconciled.
